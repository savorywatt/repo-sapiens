"""QA stage - builds and tests the project."""

import subprocess  # nosec B404 # Required for git operations with controlled input
from pathlib import Path

import structlog

from automation.engine.stages.base import WorkflowStage
from automation.models.domain import Issue, PullRequest

log = structlog.get_logger(__name__)


class QAStage(WorkflowStage):
    """Build and test project when 'requires-qa' label is present.

    This stage:
    1. Detects issues/PRs with 'requires-qa' label
    2. Checks out the branch
    3. Runs build commands (npm build, make, etc.)
    4. Runs test commands (npm test, pytest, etc.)
    5. Reports results as comment
    6. Updates label to 'qa-passed' or 'qa-failed'
    """

    async def execute(self, issue: Issue) -> None:
        """Execute QA build and test.

        Args:
            issue: Issue with 'requires-qa' label
        """
        log.info("qa_stage_start", issue=issue.number)

        # Check if already QA'd
        if "qa-passed" in issue.labels or "qa-failed" in issue.labels:
            log.debug("already_qa_checked", issue=issue.number)
            return

        # Get PR for this issue
        pr = await self._get_pr_for_issue(issue)
        if not pr:
            log.debug("no_pr_found", issue=issue.number)
            return

        log.info("qa_starting", pr=pr.number, branch=pr.head)

        try:
            # Notify start
            await self.git.add_comment(
                issue.number,
                f"ðŸ”¨ **Starting QA Build & Test**\n\n"
                f"Branch: `{pr.head}`\n"
                f"PR: #{pr.number}\n\n"
                f"I'll build the project and run tests.\n\n"
                f"ðŸ¤– Posted by Builder Automation",
            )

            # Checkout branch in playground repo
            playground_dir = Path(__file__).parent.parent.parent.parent.parent / "playground"
            if not playground_dir.exists():
                raise Exception(f"Playground repo not found at {playground_dir}")

            log.info("checking_out_branch", branch=pr.head, path=str(playground_dir))

            # Fetch and checkout
            subprocess.run(["git", "fetch", "origin"], cwd=playground_dir, check=True)  # nosec B603 B607 # Git command with controlled input
            subprocess.run(  # nosec B603 B607 # Git command with controlled input
                ["git", "checkout", "-B", pr.head, f"origin/{pr.head}"],
                cwd=playground_dir,
                check=True,
            )

            log.info("branch_checked_out", branch=pr.head)

            # Run build and test
            build_result = await self._run_build(playground_dir)
            test_result = await self._run_test(playground_dir)

            # If no tests exist, create them using the agent
            if test_result.get("command") == "none":
                log.info("no_tests_found_creating", pr=pr.number)

                await self.git.add_comment(
                    issue.number,
                    "ðŸ“ **No Tests Found - Creating Unit Tests**\n\n"
                    "I'll analyze the code and create unit tests.\n\n"
                    "ðŸ¤– Posted by Builder Automation",
                )

                # Use agent to create tests
                test_creation_result = await self._create_tests(playground_dir, pr)

                if test_creation_result["success"]:
                    # Commit the new tests
                    subprocess.run(["git", "add", "."], cwd=playground_dir, check=True)  # nosec B603 B607 # Git command with controlled input

                    # Check if there are changes to commit
                    status_result = subprocess.run(  # nosec B603 B607 # Git command with controlled input
                        ["git", "status", "--porcelain"],
                        cwd=playground_dir,
                        capture_output=True,
                        text=True,
                        check=True,
                    )

                    if status_result.stdout.strip():
                        commit_message = (
                            f"test: Add unit tests for PR #{pr.number}\n\n"
                            "ðŸ¤– Auto-generated by Builder QA"
                        )
                        subprocess.run(  # nosec B603 B607 # Git command with controlled input
                            ["git", "commit", "-m", commit_message], cwd=playground_dir, check=True
                        )
                        subprocess.run(  # nosec B603 B607 # Git command with controlled input
                            ["git", "push", "origin", pr.head], cwd=playground_dir, check=True
                        )
                        log.info("tests_created_and_committed", pr=pr.number)

                        # Run tests again after creating them
                        test_result = await self._run_test(playground_dir)
                    else:
                        log.warning("no_test_files_created", pr=pr.number)

            # Determine if QA passed
            qa_passed = build_result["success"] and test_result["success"]

            # Post results
            result_lines = [
                f"{'âœ…' if qa_passed else 'âŒ'} **QA {'Passed' if qa_passed else 'Failed'}**\n",
                f"Branch: `{pr.head}`\n",
                f"PR: #{pr.number}\n",
                "",
                "## Build",
                f"Status: {'âœ… Success' if build_result['success'] else 'âŒ Failed'}",
            ]

            if build_result.get("output"):
                result_lines.append(f"```\n{build_result['output'][-1000:]}\n```")

            result_lines.extend(
                [
                    "",
                    "## Tests",
                    f"Status: {'âœ… Success' if test_result['success'] else 'âŒ Failed'}",
                ]
            )

            if test_result.get("output"):
                result_lines.append(f"```\n{test_result['output'][-1000:]}\n```")

            result_lines.extend(["", "---", "", "ðŸ¤– Posted by Builder Automation"])

            await self.git.add_comment(issue.number, "\n".join(result_lines))

            # Update labels
            updated_labels = [label for label in issue.labels if label != "requires-qa"]
            updated_labels.append("qa-passed" if qa_passed else "qa-failed")
            await self.git.update_issue(issue.number, labels=updated_labels)

            log.info("qa_complete", issue=issue.number, passed=qa_passed)

        except Exception as e:
            log.error("qa_failed", issue=issue.number, error=str(e), exc_info=True)
            await self.git.add_comment(
                issue.number,
                f"âŒ **QA Failed**\n\n"
                f"Error: {str(e)}\n\n"
                f"Please review the error and try again.\n\n"
                f"ðŸ¤– Posted by Builder Automation",
            )
            raise

    async def _get_pr_for_issue(self, issue: Issue) -> "PullRequest | None":
        """Try to find a PR associated with this issue.

        In Gitea, PRs are also issues, so we try to get a PR with the same number.
        """
        try:
            # Try to get PR with the same number as the issue
            pr = await self.git.get_pull_request(issue.number)
            return pr
        except Exception as e:
            log.debug("pr_lookup_failed", issue=issue.number, error=str(e))
            return None

    async def _run_build(self, project_dir: Path) -> dict:
        """Run build commands for the project.

        Returns:
            dict with 'success' and 'output' keys
        """
        log.info("running_build", dir=str(project_dir))

        # Try different build methods
        build_commands = [
            # Node.js
            (["npm", "run", "build"], "package.json"),
            (["yarn", "build"], "package.json"),
            # Python
            (["python", "setup.py", "build"], "setup.py"),
            (["python", "-m", "build"], "pyproject.toml"),
            # Make
            (["make"], "Makefile"),
            # Go
            (["go", "build", "./..."], "go.mod"),
        ]

        for cmd, indicator_file in build_commands:
            if (project_dir / indicator_file).exists():
                log.info("running_build_command", cmd=cmd)
                try:
                    result = subprocess.run(  # nosec B603 # Build commands from predefined list
                        cmd,
                        cwd=project_dir,
                        capture_output=True,
                        text=True,
                        timeout=300,  # 5 minute timeout
                    )
                    return {
                        "success": result.returncode == 0,
                        "output": result.stdout + result.stderr,
                        "command": " ".join(cmd),
                    }
                except subprocess.TimeoutExpired:
                    return {
                        "success": False,
                        "output": "Build timed out after 5 minutes",
                        "command": " ".join(cmd),
                    }
                except FileNotFoundError:
                    log.debug("build_command_not_found", cmd=cmd[0])
                    continue

        # No build system found - consider it a success (static files, etc.)
        log.info("no_build_system_found")
        return {
            "success": True,
            "output": "No build system detected (static project)",
            "command": "none",
        }

    async def _create_tests(self, project_dir: Path, pr: any) -> dict:
        """Use agent to create unit tests for the project.

        Returns:
            dict with 'success' and 'output' keys
        """
        log.info("creating_tests_with_agent", pr=pr.number, dir=str(project_dir))

        # Build prompt for agent to create tests
        prompt = f"""You are creating unit tests for PR #{pr.number}.

**PR Title**: {pr.title}
**PR Description**:
{pr.body}

**Instructions**:
1. Analyze the code in this project
2. Identify the main functionality that needs testing
3. Create comprehensive unit tests with good coverage
4. Use appropriate testing frameworks for the language:
   - JavaScript/TypeScript: Jest, Mocha, or similar
   - Python: pytest or unittest
   - Go: built-in testing package
5. Create test files following conventions:
   - JavaScript: *.test.js or *.spec.js
   - Python: test_*.py in tests/ directory
   - Go: *_test.go
6. Include:
   - Basic functionality tests
   - Edge case tests
   - Error handling tests

**CRITICAL**:
- Create ACTUAL test files, don't just describe them
- Tests should be runnable and pass
- Follow best practices for the language/framework
- Add any necessary test dependencies to package.json, requirements.txt, etc.

Focus on creating working, comprehensive tests that validate the code works correctly.
"""

        # Temporarily change agent working directory
        original_working_dir = self.agent.working_dir
        self.agent.working_dir = str(project_dir)

        try:
            result = await self.agent.execute_prompt(prompt, {}, f"qa-tests-{pr.number}")

            return {
                "success": result.get("success", False),
                "output": result.get("output", ""),
                "error": result.get("error"),
            }
        finally:
            # Restore original working directory
            self.agent.working_dir = original_working_dir

    async def _run_test(self, project_dir: Path) -> dict:
        """Run test commands for the project.

        Returns:
            dict with 'success' and 'output' keys
        """
        log.info("running_tests", dir=str(project_dir))

        # Try different test methods
        test_commands = [
            # Node.js
            (["npm", "test"], "package.json"),
            (["yarn", "test"], "package.json"),
            # Python
            (["pytest"], "pytest.ini"),
            (["pytest"], "pyproject.toml"),
            (["python", "-m", "pytest"], "tests"),
            (["python", "-m", "unittest", "discover"], "tests"),
            # Make
            (["make", "test"], "Makefile"),
            # Go
            (["go", "test", "./..."], "go.mod"),
        ]

        for cmd, indicator_file in test_commands:
            indicator_path = project_dir / indicator_file
            if indicator_path.exists() or (
                indicator_path.is_dir() if indicator_path.name == "tests" else False
            ):
                log.info("running_test_command", cmd=cmd)
                try:
                    result = subprocess.run(  # nosec B603 # Test commands from predefined list
                        cmd,
                        cwd=project_dir,
                        capture_output=True,
                        text=True,
                        timeout=300,  # 5 minute timeout
                    )
                    return {
                        "success": result.returncode == 0,
                        "output": result.stdout + result.stderr,
                        "command": " ".join(cmd),
                    }
                except subprocess.TimeoutExpired:
                    return {
                        "success": False,
                        "output": "Tests timed out after 5 minutes",
                        "command": " ".join(cmd),
                    }
                except FileNotFoundError:
                    log.debug("test_command_not_found", cmd=cmd[0])
                    continue

        # No test system found - consider it a success (no tests yet)
        log.info("no_test_system_found")
        return {
            "success": True,
            "output": "No test system detected (no tests found)",
            "command": "none",
        }
