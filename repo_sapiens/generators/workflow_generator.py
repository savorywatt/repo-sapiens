"""
Generate native CI/CD workflow files from trigger configuration.

Supports Gitea Actions, GitHub Actions, and GitLab CI.
"""

from pathlib import Path
from typing import Any

import structlog
import yaml

from repo_sapiens.config.settings import AutomationSettings
from repo_sapiens.config.triggers import (
    ScheduleTriggerConfig,
)

log = structlog.get_logger(__name__)


class WorkflowGenerator:
    """Generates native CI/CD workflow files."""

    def __init__(
        self,
        settings: AutomationSettings,
        output_dir: Path,
    ):
        """Initialize generator.

        Args:
            settings: Automation settings
            output_dir: Root directory for workflow files
        """
        self.settings = settings
        self.automation = settings.automation
        self.provider = settings.git_provider.provider_type
        self.output_dir = output_dir

    def generate_all(self) -> list[Path]:
        """Generate all workflow files.

        Returns:
            List of generated file paths
        """
        generated = []

        # Generate label trigger workflow
        if self.automation.label_triggers:
            path = self.generate_label_workflow()
            if path:
                generated.append(path)

        # Generate schedule workflows
        for schedule in self.automation.schedule_triggers:
            path = self.generate_schedule_workflow(schedule)
            if path:
                generated.append(path)

        return generated

    def generate_label_workflow(self) -> Path | None:
        """Generate the label-triggered workflow.

        Returns:
            Path to generated file or None
        """
        if self.provider == "gitlab":
            return self._generate_gitlab_label_workflow()
        else:
            return self._generate_actions_label_workflow()

    def _generate_actions_label_workflow(self) -> Path:
        """Generate Gitea/GitHub Actions label workflow."""
        # Determine workflow directory
        if self.provider == "github":
            workflow_dir = self.output_dir / ".github" / "workflows" / "sapiens"
        else:
            workflow_dir = self.output_dir / ".gitea" / "workflows" / "sapiens"

        workflow_dir.mkdir(parents=True, exist_ok=True)

        # Build label patterns for condition
        label_patterns = list(self.automation.label_triggers.keys())

        # Generate workflow content
        workflow = {
            "name": "Process Label",
            "on": {
                "issues": {
                    "types": ["labeled"],
                },
                "pull_request": {
                    "types": ["labeled"],
                },
            },
            "jobs": {
                "process": {
                    "runs-on": "ubuntu-latest",
                    "if": self._build_label_condition(label_patterns),
                    "steps": [
                        {
                            "name": "Checkout repository",
                            "uses": "actions/checkout@v4",
                        },
                        {
                            "name": "Set up Python",
                            "uses": "actions/setup-python@v5",
                            "with": {
                                "python-version": "3.12",
                            },
                        },
                        {
                            "name": "Install repo-sapiens",
                            "run": "pip install repo-sapiens",
                        },
                        {
                            "name": "Process label event",
                            "env": self._build_env_block(),
                            "run": self._build_run_command(),
                        },
                    ],
                },
            },
        }

        # Write workflow file
        output_path = workflow_dir / "process-label.yaml"
        with open(output_path, "w") as f:
            f.write("# Generated by repo-sapiens\n")
            f.write("# Do not edit manually - regenerate with 'sapiens update --workflows'\n\n")
            yaml.dump(workflow, f, default_flow_style=False, sort_keys=False)

        log.info("generated_workflow", path=str(output_path))
        return output_path

    def _generate_gitlab_label_workflow(self) -> Path:
        """Generate GitLab CI label workflow."""
        gitlab_ci_path = self.output_dir / ".gitlab-ci.yml"

        # GitLab CI uses different syntax
        workflow: dict[str, Any] = {
            "stages": ["process"],
            "process-label": {
                "stage": "process",
                "image": "python:3.12",
                "rules": [
                    {
                        "if": '$CI_PIPELINE_SOURCE == "merge_request_event"',
                        "when": "always",
                    },
                    {
                        "changes": ["**/*.py"],
                        "when": "never",  # Don't run on code changes
                    },
                ],
                "before_script": [
                    "pip install repo-sapiens",
                ],
                "script": [
                    'sapiens process-label --event-type "merge_request.labeled" '
                    '--label "$CI_MERGE_REQUEST_LABELS" '
                    '--issue "$CI_MERGE_REQUEST_IID" '
                    "--source gitlab",
                ],
            },
        }

        # Merge with existing gitlab-ci.yml if present
        if gitlab_ci_path.exists():
            with open(gitlab_ci_path) as f:
                existing = yaml.safe_load(f) or {}

            # Add our job to existing config
            existing["process-label"] = workflow["process-label"]
            if "process" not in existing.get("stages", []):
                existing.setdefault("stages", []).append("process")

            workflow = existing

        with open(gitlab_ci_path, "w") as f:
            f.write("# Generated/updated by repo-sapiens\n\n")
            yaml.dump(workflow, f, default_flow_style=False, sort_keys=False)

        log.info("generated_gitlab_ci", path=str(gitlab_ci_path))
        return gitlab_ci_path

    def _build_label_condition(self, patterns: list[str]) -> str:
        """Build the 'if' condition for label matching.

        Args:
            patterns: List of label patterns to match

        Returns:
            Condition string for workflow
        """
        if self.provider == "github":
            event_var = "github.event.label.name"
        else:
            event_var = "gitea.event.label.name"

        # Build condition for each pattern
        conditions = []
        for pattern in patterns:
            if "*" in pattern:
                # Glob pattern - use startsWith for prefix matching
                prefix = pattern.split("*")[0]
                conditions.append(f"startsWith({event_var}, '{prefix}')")
            else:
                # Exact match
                conditions.append(f"{event_var} == '{pattern}'")

        return " || ".join(conditions)

    def _build_env_block(self) -> dict[str, str]:
        """Build environment variables block."""
        if self.provider == "github":
            # Note: GITHUB_ prefix is reserved for custom secrets, so we use SAPIENS_GITHUB_TOKEN
            return {
                "GITHUB_TOKEN": "${{ secrets.SAPIENS_GITHUB_TOKEN }}",
                "AUTOMATION__GIT_PROVIDER__API_TOKEN": "${{ secrets.SAPIENS_GITHUB_TOKEN }}",
                "AUTOMATION__GIT_PROVIDER__BASE_URL": "${{ github.server_url }}",
                "AUTOMATION__REPOSITORY__OWNER": "${{ github.repository_owner }}",
                "AUTOMATION__REPOSITORY__NAME": "${{ github.event.repository.name }}",
            }
        else:  # gitea
            return {
                "GITEA_TOKEN": "${{ secrets.SAPIENS_GITEA_TOKEN }}",
                "AUTOMATION__GIT_PROVIDER__API_TOKEN": "${{ secrets.SAPIENS_GITEA_TOKEN }}",
                "AUTOMATION__GIT_PROVIDER__BASE_URL": "${{ gitea.server_url }}",
                "AUTOMATION__REPOSITORY__OWNER": "${{ gitea.repository_owner }}",
                "AUTOMATION__REPOSITORY__NAME": "${{ gitea.event.repository.name }}",
            }

    def _build_run_command(self) -> str:
        """Build the sapiens run command."""
        if self.provider == "github":
            return (
                "sapiens process-label "
                '--event-type "issues.labeled" '
                '--label "${{ github.event.label.name }}" '
                '--issue "${{ github.event.issue.number || github.event.pull_request.number }}" '
                "--source github"
            )
        else:  # gitea
            return (
                "sapiens process-label "
                '--event-type "issues.labeled" '
                '--label "${{ gitea.event.label.name }}" '
                '--issue "${{ gitea.event.issue.number || gitea.event.pull_request.number }}" '
                "--source gitea"
            )

    def generate_schedule_workflow(
        self,
        schedule: ScheduleTriggerConfig,
    ) -> Path | None:
        """Generate a scheduled workflow.

        Args:
            schedule: Schedule configuration

        Returns:
            Path to generated file or None
        """
        # Safe filename from handler name
        filename = f"schedule-{schedule.handler.replace('/', '-')}.yaml"

        if self.provider == "gitlab":
            # GitLab uses pipeline schedules (configured in UI)
            log.warning(
                "gitlab_schedules_manual",
                handler=schedule.handler,
                cron=schedule.cron,
            )
            return None

        # Gitea/GitHub Actions
        if self.provider == "github":
            workflow_dir = self.output_dir / ".github" / "workflows" / "sapiens"
        else:
            workflow_dir = self.output_dir / ".gitea" / "workflows" / "sapiens"

        workflow_dir.mkdir(parents=True, exist_ok=True)

        workflow = {
            "name": f"Scheduled: {schedule.handler}",
            "on": {
                "schedule": [
                    {"cron": schedule.cron},
                ],
                "workflow_dispatch": {},
            },
            "jobs": {
                "run": {
                    "runs-on": "ubuntu-latest",
                    "steps": [
                        {
                            "name": "Checkout repository",
                            "uses": "actions/checkout@v4",
                        },
                        {
                            "name": "Set up Python",
                            "uses": "actions/setup-python@v5",
                            "with": {
                                "python-version": "3.12",
                            },
                        },
                        {
                            "name": "Install repo-sapiens",
                            "run": "pip install repo-sapiens",
                        },
                        {
                            "name": f"Run {schedule.handler}",
                            "env": self._build_env_block(),
                            "run": f'sapiens run "{schedule.task_prompt or schedule.handler}"',
                        },
                    ],
                },
            },
        }

        output_path = workflow_dir / filename
        with open(output_path, "w") as f:
            f.write("# Generated by repo-sapiens\n")
            f.write(f"# Schedule: {schedule.cron}\n\n")
            yaml.dump(workflow, f, default_flow_style=False, sort_keys=False)

        log.info("generated_schedule_workflow", path=str(output_path))
        return output_path
